a1 <- sum( v1 * u1 )
a2 <- sum( v2 * u2 )
a3 <- sum( v3 * u3 )
a4 <- sum( v4 * u4 )
# Weighted average of the scalar products
s <- function(p) 3 * p^2 - 2 * p^3
p <- s( x - i )
q <- s( y - j )
b1 <- (1-p)*a1 + p*a2
b2 <- (1-p)*a3 + p*a4
(1-q) * b1 + q * b2
}
xs <- seq(from = 1, to = n, length = N+1)[-(N+1)]
ys <- seq(from = 1, to = m, length = M+1)[-(M+1)]
outer( xs, ys, Vectorize(f) )
}
image( perlin_noise() )
perlin_noise <- function(
n = 3,   m = 3,    # Size of the grid for the vector field
N = 150, M = 150   # Dimension of the image
) {
# For each point on this n*m grid, choose a unit 1 vector
vector_field <- apply(
array( rnorm( 2 * n * m ), dim = c(2,n,m) ),
2:3,
function(u) u / sqrt(sum(u^2))
)
f <- function(x,y) {
# Find the grid cell in which the point (x,y) is
i <- floor(x)
j <- floor(y)
stopifnot( i >= 1 || j >= 1 || i < n || j < m )
# The 4 vectors, from the vector field, at the vertices of the square
v1 <- vector_field[,i,j]
v2 <- vector_field[,i+1,j]
v3 <- vector_field[,i,j+1]
v4 <- vector_field[,i+1,j+1]
# Vectors from the point to the vertices
u1 <- c(x,y) - c(i,j)
u2 <- c(x,y) - c(i+1,j)
u3 <- c(x,y) - c(i,j+1)
u4 <- c(x,y) - c(i+1,j+1)
# Scalar products
a1 <- sum( v1 * u1 )
a2 <- sum( v2 * u2 )
a3 <- sum( v3 * u3 )
a4 <- sum( v4 * u4 )
# Weighted average of the scalar products
s <- function(p) 3 * p^2 - 2 * p^3
p <- s( x - i )
q <- s( y - j )
b1 <- (1-p)*a1 + p*a2
b2 <- (1-p)*a3 + p*a4
(1-q) * b1 + q * b2
}
xs <- seq(from = 1, to = n, length = N+1)[-(N+1)]
ys <- seq(from = 1, to = m, length = M+1)[-(M+1)]
outer( xs, ys, Vectorize(f) )
}
image( perlin_noise() )
image( perlin_noise() )
image( perlin_noise() )
image( perlin_noise() )
land = perlin_noise()
View(land)
rnorm( 2 * n * m )
perlin_noise <- function(
n = 3,   m = 3,    # Size of the grid for the vector field
N = 150, M = 150   # Dimension of the image
) {
# For each point on this n*m grid, choose a unit 1 vector
vector_field <- apply(
array( rnorm( 2 * n * m ), dim = c(2,n,m) ),
2:3,
function(u) u / sqrt(sum(u^2))
)
f <- function(x,y) {
# Find the grid cell in which the point (x,y) is
i <- floor(x)
j <- floor(y)
stopifnot( i >= 1 || j >= 1 || i < n || j < m )
# The 4 vectors, from the vector field, at the vertices of the square
v1 <- vector_field[,i,j]
v2 <- vector_field[,i+1,j]
v3 <- vector_field[,i,j+1]
v4 <- vector_field[,i+1,j+1]
# Vectors from the point to the vertices
u1 <- c(x,y) - c(i,j)
u2 <- c(x,y) - c(i+1,j)
u3 <- c(x,y) - c(i,j+1)
u4 <- c(x,y) - c(i+1,j+1)
# Scalar products
a1 <- sum( v1 * u1 )
a2 <- sum( v2 * u2 )
a3 <- sum( v3 * u3 )
a4 <- sum( v4 * u4 )
# Weighted average of the scalar products
s <- function(p) 3 * p^2 - 2 * p^3
p <- s( x - i )
q <- s( y - j )
b1 <- (1-p)*a1 + p*a2
b2 <- (1-p)*a3 + p*a4
(1-q) * b1 + q * b2
}
xs <- seq(from = 1, to = n, length = N+1)[-(N+1)]
ys <- seq(from = 1, to = m, length = M+1)[-(M+1)]
outer( xs, ys, Vectorize(f) )
}
n = 3,   m = 3,    # Size of the grid for the vector field
N = 150, M = 150
xpeak = sample(1:landscape, npeaks, replace=F)
ypeak = sample(1:landscape, npeaks, replace=F)
land[xpeak, ypeak] = elevation[2]
land[xpeak, ypeak]
ypeak
View(land)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
land[xpeak, ypeak] = elevation[2]
View(land)
xpeak
image(land)
xpeak
ypeak
?image
image(land, xlim=c(1,landscape), ylim=c(1,landscape))
image(land)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, npeaks, replace=F)
ypeak = sample(1:landscape, npeaks, replace=F)
for(p in 1:npeaks){
land[xpeak[p], ypeak[p]] = elevation[2]
}
image(land)
image(land, xlim=c(1,landscape), ylim=c(1,landscape))
image(land)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, npeaks, replace=F)
ypeak = sample(1:landscape, npeaks, replace=F)
for(p in 1:npeaks){
land[xpeak[p], ypeak[p]] = elevation[2]
}
image(land, xlim=c(1,landscape), ylim=c(1,landscape))
image(land)
npeaks    = 2                   #number of peaks
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, npeaks, replace=F)
ypeak = sample(1:landscape, npeaks, replace=F)
for(p in 1:npeaks){
land[xpeak[p], ypeak[p]] = elevation[2]
}
image(land, xlim=c(1,landscape), ylim=c(1,landscape))
image(land)
xvall = sample(1:landscape, npeaks, replace=F)
yvall = sample(1:landscape, npeaks, replace=F)
for(p in 1:npeaks){
land[xvall[p], yvall[p]] = elevation[1]
}
image(land)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, npeaks, replace=F)
ypeak = sample(1:landscape, npeaks, replace=F)
for(p in 1:npeaks){
land[xpeak[p], ypeak[p]] = elevation[2]
}
xvall = sample(1:landscape, npeaks, replace=F)
yvall = sample(1:landscape, npeaks, replace=F)
for(p in 1:npeaks){
land[xvall[p], yvall[p]] = elevation[1]
}
image(land, xlim=c(1,landscape), ylim=c(1,landscape))
image(land)
xvall
xpeak
ypeak
yvall
land = perlin_noise()
View(land)
image( perlin_noise() )
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
land[xpeak, ypeak]
xs <- seq(from = elevation[1], to = elevation[2], length = landscape+1)[-(landscape+1)]
ys <- seq(from = 1, to = 3, length = landscape+1)[-(landscape+1)]
outer( xs, ys, Vectorize(f) )
f <- function(x,y,xpeak,ypeak) {
# Find the grid cell in which the point (x,y) is
i <- xpeak
j <- ypeak
stopifnot( i >= 1 || j >= 1 || i < n || j < m )
# The 4 vectors, from the vector field, at the vertices of the square
v1 <- vector_field[,i,j]
v2 <- vector_field[,i+1,j]
v3 <- vector_field[,i,j+1]
v4 <- vector_field[,i+1,j+1]
# Vectors from the point to the vertices
u1 <- c(x,y) - c(i,j)
u2 <- c(x,y) - c(i+1,j)
u3 <- c(x,y) - c(i,j+1)
u4 <- c(x,y) - c(i+1,j+1)
# Scalar products
a1 <- sum( v1 * u1 )
a2 <- sum( v2 * u2 )
a3 <- sum( v3 * u3 )
a4 <- sum( v4 * u4 )
# Weighted average of the scalar products
s <- function(p) 3 * p^2 - 2 * p^3
p <- s( x - i )
q <- s( y - j )
b1 <- (1-p)*a1 + p*a2
b2 <- (1-p)*a3 + p*a4
(1-q) * b1 + q * b2
}
xs <- seq(from = elevation[1], to = elevation[2], length = landscape+1)[-(landscape+1)]
ys <- seq(from = 1, to = 3, length = landscape+1)[-(landscape+1)]
outer( xs, ys, Vectorize(f) )
f <- function(1,1,xpeak,ypeak) {
# Find the grid cell in which the point (x,y) is
i <- xpeak
j <- ypeak
stopifnot( i >= 1 || j >= 1 || i < n || j < m )
# The 4 vectors, from the vector field, at the vertices of the square
v1 <- vector_field[,i,j]
v2 <- vector_field[,i+1,j]
v3 <- vector_field[,i,j+1]
v4 <- vector_field[,i+1,j+1]
# Vectors from the point to the vertices
u1 <- c(x,y) - c(i,j)
u2 <- c(x,y) - c(i+1,j)
u3 <- c(x,y) - c(i,j+1)
u4 <- c(x,y) - c(i+1,j+1)
# Scalar products
a1 <- sum( v1 * u1 )
a2 <- sum( v2 * u2 )
a3 <- sum( v3 * u3 )
a4 <- sum( v4 * u4 )
# Weighted average of the scalar products
s <- function(p) 3 * p^2 - 2 * p^3
p <- s( x - i )
q <- s( y - j )
b1 <- (1-p)*a1 + p*a2
b2 <- (1-p)*a3 + p*a4
(1-q) * b1 + q * b2
}
f <- function(x=1,y=1,xpeak=xpeak,ypeak=ypeak) {
# Find the grid cell in which the point (x,y) is
i <- xpeak
j <- ypeak
stopifnot( i >= 1 || j >= 1 || i < n || j < m )
# The 4 vectors, from the vector field, at the vertices of the square
v1 <- vector_field[,i,j]
v2 <- vector_field[,i+1,j]
v3 <- vector_field[,i,j+1]
v4 <- vector_field[,i+1,j+1]
# Vectors from the point to the vertices
u1 <- c(x,y) - c(i,j)
u2 <- c(x,y) - c(i+1,j)
u3 <- c(x,y) - c(i,j+1)
u4 <- c(x,y) - c(i+1,j+1)
# Scalar products
a1 <- sum( v1 * u1 )
a2 <- sum( v2 * u2 )
a3 <- sum( v3 * u3 )
a4 <- sum( v4 * u4 )
# Weighted average of the scalar products
s <- function(p) 3 * p^2 - 2 * p^3
p <- s( x - i )
q <- s( y - j )
b1 <- (1-p)*a1 + p*a2
b2 <- (1-p)*a3 + p*a4
(1-q) * b1 + q * b2
}
xs <- seq(from = elevation[1], to = elevation[2], length = landscape+1)[-(landscape+1)]
ys <- seq(from = 1, to = 3, length = landscape+1)[-(landscape+1)]
outer( xs, ys, Vectorize(f) )
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
install.packages("NLMR")
devtools::install_github("ropensci/NLMR")
#devtools::install_github("ropensci/NLMR")
library(NLMR)
?nlm_distancegradient
nlm_distancegradient(ncol=landscape, nrow=landscape, resolution=1, origin=c(xpeak, ypeak))
land[xpeak, ]
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2]) + rnorm(0,1,length(1:(ypeak-1)))
seq(elevation[1], elevation[2])
rnorm(0,1,length(1:(ypeak-1))
seq(elevation[1], elevation[2]) + rnorm(0,1,length(1:(ypeak-1))))
?rnorm
seq(elevation[1], elevation[2]) + rnorm(length(1:(ypeak-1))0,1)
seq(elevation[1], elevation[2]) + rnorm(length(1:(ypeak-1)),0,1)
seq(elevation[1], elevation[2]) + rnorm((length(1:(ypeak-1))+length(1:(ypeak+1))),0,1)
rnorm((length(1:(ypeak-1))+length(1:(ypeak+1))),0,1)
seq(elevation[1], elevation[2])
?seq
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[1], elevation[2])/(xpeak-1)) + rnorm((length(1:(ypeak-1))+length(1:(ypeak+1))),0,1)
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-1)) + rnorm((length(1:(ypeak-1))+length(1:(ypeak+1))),0,1)
seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-1))
xpeak
length(rnorm((length(1:(ypeak-1))+length(1:(ypeak+1))),0,1))
rnorm((length(1:(ypeak-1))),0,1)
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak)) + rnorm(ypeak,0,1)
rnorm(ypeak,0,1)
ypeak
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-1)) + rnorm((xpeak-1),0,1)
seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-1)) + rnorm((xpeak-1),0,1)
rnorm((xpeak-1),0,1)
seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-1))
seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1)
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1)
length(1:(ypeak-1))
seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1)
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1)
land[xpeak, 1:(ypeak+1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak+2)) + rnorm((ypeak+1),0,1)
length(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak+2)))
land[xpeak, (ypeak+1):landscape] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-2)) + rnorm((landscape-ypeak-1),0,1)
length(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-2)))
length(rnorm((landscape-ypeak-1),0,1))
length((ypeak+1):landscape)
land[xpeak, (ypeak+1):landscape] = seq(elevation[2], elevation[1], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),0,1)
land[xpeak, (ypeak+1):landscape] = rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),0,1))
land
View(land)
#set peak y values
land[1:(xpeak-1), ypeak] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1)
land[(xpeak+1):landscape, ypeak] = rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-xpeak-1)) + rnorm((landscape-xpeak),0,1))
View(land)
?round
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak x values
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1)
land[xpeak, (ypeak+1):landscape] = rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + round(rnorm((landscape-ypeak),5,2)), 0)
land[xpeak, (ypeak+1):landscape] = rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + round(rnorm((landscape-ypeak),5,2), 0))
#set peak y values
land[1:(xpeak-1), ypeak] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1)
land[(xpeak+1):landscape, ypeak] = rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-xpeak-1)) + round(rnorm((landscape-xpeak),5,2), 0))
View(land)
round(rnorm((landscape-ypeak),5,2), 0))
round(rnorm((landscape-ypeak),5,2), 0)
round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2), 0))
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak x values
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1)
land[xpeak, (ypeak+1):landscape] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
#set peak y values
land[1:(xpeak-1), ypeak] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1)
land[(xpeak+1):landscape, ypeak] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-xpeak-1)) + rnorm((landscape-xpeak),5,2)), 0)
View(land)
xpeak
round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak x values
land[xpeak, 1:(ypeak-1)] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1)
land[xpeak, (ypeak+1):landscape] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
#set peak y values
land[1:(xpeak-1), ypeak] = seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1)
land[(xpeak+1):landscape, ypeak] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-xpeak-1)) + rnorm((landscape-xpeak),5,2)), 0)
land[xpeak]
land[ypeak]
land[,ypeak]
land[xpeak,]
round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1), 0)
round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1), 0)
round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-xpeak-1)) + rnorm((landscape-xpeak),5,2)), 0)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak x values
land[xpeak, 1:(ypeak-1)] = round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1), 0)
land[xpeak, (ypeak+1):landscape] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
#set peak y values
land[1:(xpeak-1), ypeak] = round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(xpeak-2)) + rnorm((xpeak-1),0,1), 0)
land[(xpeak+1):landscape, ypeak] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-xpeak-1)) + rnorm((landscape-xpeak),5,2)), 0)
land[xpeak, ypeak]
land[xpeak, ]
land[, ypeak]
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak row/column values
land[xpeak, 1:(ypeak-1)] = round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1), 0)
land[xpeak, (ypeak+1):landscape] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
land[xpeak,]
for(r in xpeak-1:1){
land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
}
View(land)
xpeak-1
for(r in x(peak-1):1){
land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
}
for(r in (xpeak-1):1){
land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
}
View(land)
for(r in (xpeak+1):landscape){
land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
}
for(r in (xpeak+1):landscape){
land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
}
View(land)
image( land )
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak row/column values
land[xpeak, 1:(ypeak-1)] = round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1), 0)
land[xpeak, (ypeak+1):landscape] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
#work from edges and fill in elevation
for(r in (xpeak-1):1){
land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 2), 0)
}
for(r in (xpeak+1):landscape){
land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 2), 0)
}
image(land)
#initialize landscape
land  = matrix(nrow=landscape, ncol=landscape)
xpeak = sample(1:landscape, 1)
ypeak = sample(1:landscape, 1)
land[xpeak, ypeak] = elevation[2]
#set peak row/column values
land[xpeak, 1:(ypeak-1)] = round(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(ypeak-2)) + rnorm((ypeak-1),0,1), 0)
land[xpeak, (ypeak+1):landscape] = round(rev(seq(elevation[1], elevation[2], (elevation[2]-elevation[1])/(landscape-ypeak-1)) + rnorm((landscape-ypeak),5,2)), 0)
#work from edges and fill in elevation
for(r in (xpeak-1):1){
land[r,] = land[(r+1),] - round(rnorm(landscape, 5, 1), 0)
}
for(r in (xpeak+1):landscape){
land[r,] = land[(r-1),] - round(rnorm(landscape, 5, 1), 0)
}
image(land)
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 500                 #number of individuals to simulate
nsteps    = 1000                #number of steps an individual can take
move      = 0.8                 #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
#initialize landscape
land = LandscapeInit(elevation)
image(land)
#initialize landscape
land = LandscapeInit(elevation)
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = 0.8                 #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
#initialize landscape
land = LandscapeInit(elevation)
image(land)
#initialize landscape
land = LandscapeInit(elevation)
image(land)
#initialize landscape
land = LandscapeInit(elevation)
image(land)
#initialize landscape
land = LandscapeInit(elevation)
image(land)
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = 0.8                 #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
#initialize landscape
land = LandscapeInit(elevation)
image(land)
