indv = pop[i,,drop=FALSE]
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
?expand.grid
parameters = expand.grid(elevation,landscape,nindvs,nsteps,move)
View(parameters)
colnames("elevation","landscape","nindvs","nsteps","move")
colnames(parameters) = c("elevation","landscape","nindvs","nsteps","move")
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = 0.8 #c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
# create the profit and risk variables
profit<-seq(-2000,20000,by=1000)
risk<-seq(0.01,0.1,by=0.01)
# create the array to contour
profit.risk<-expand.grid(profit=profit,risk=risk)
# function to calculate utility
calc.utility<-
function(current.value,time.horizon,profit.risk)
# function to calculate utility
calc.utility<-
function(current.value,time.horizon,profit.risk)
{
max(0,(current.value+(time.horizon*profit.risk["profit"]))
* (1-profit.risk["risk"])^time.horizon)
}
# create an array containing utility values
utility<-apply(profit.risk,1,calc.utility,current.value=0,
time.horizon=5)
# draw the contour plot
filled.contour(profit,risk,
matrix(utility,ncol=length(risk)),
col=grey(0:24/24),xlab="profit",ylab="risk")
# create the array to contour
profit.risk<-expand.grid(profit=profit,risk=risk)
profit.risk
# function to calculate utility
calc.utility<-function(current.value,time.horizon,profit.risk){
max(0,(current.value+(time.horizon*profit.risk["profit"])) * (1-profit.risk["risk"])^time.horizon)
}
# create an array containing utility values
utility<-apply(profit.risk,1,calc.utility,current.value=0, time.horizon=5)
utility
# draw the contour plot
filled.contour(profit,risk,matrix(utility,ncol=length(risk)), col=grey(0:24/24),xlab="profit",ylab="risk")
filled.contour(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
filled.contour(land) #image(land)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
image(land)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
set.seed(2112)
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = 0.8 #c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps      = 10                  #number of replicates to run each model
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
set.seed(2112)
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = 0.8 #c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps      = 10                  #number of replicates to run each model
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
?set.seed
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)]
mvmt = indv[1,1:2] #x==1, y==2
s=`1`
s=1
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
#determine if indv will move randomly or will move to higher elevation
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
movehigh
land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)]
max(land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)])
which(land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)]), arr.ind = TRUE)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1),
(cypos-1):(cypos+1)]), arr.ind = TRUE)
#calculate new position (x and y values)
if(highpt[1]==1){xpos = cxpos - 1 }
if(highpt[1]==2){xpos = cxpos }
if(highpt[1]==3){xpos = cxpos + 1 }
if(highpt[2]==1){ypos = cypos - 1 }
if(highpt[2]==2){ypos = cypos }
if(highpt[2]==3){ypos = cypos + 1 }
mvmt = c(mvmt, xpos, ypos)
mvmt
(
(
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = 0.8 #c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps      = 10                  #number of replicates to run each model
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps      = 10                  #number of replicates to run each model
parameters = expand.grid(elevation,landscape,nindvs,nsteps,move)
View(parameters)
colnames(parameters) = c("elevation","landscape","nindvs","nsteps","move")
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation = c(0, 400)           #peak elevation min and max
landscape = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs    = 50                  #number of individuals to simulate
nsteps    = 500                 #number of steps an individual can take
move      = c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps      = 10                  #number of replicates to run each model
parameters = expand.grid(elevation,landscape,nindvs,nsteps,move)
colnames(parameters) = c("elevation","landscape","nindvs","nsteps","move")
View(parameters)
View(parameters)
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
elevation.V = c(0, 400)           #peak elevation min and max
landscape.V = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs.V    = 50                  #number of individuals to simulate
nsteps.V    = 500                 #number of steps an individual can take
move.V      = c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps.V      = 10                 #number of replicates to run each model
parameters = expand.grid(elevation.V,landscape.V,nindvs.V,nsteps.V,move.V)
colnames(parameters) = c("elevation","landscape","nindvs","nsteps","move")
parameters = parameters[parameters$elevation!=0,]
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation.V = c(0, 400)           #peak elevation min and max
landscape.V = 150                 #number of patches on each side, total patch number = landscape*landscape
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation.V = c(0, 400)           #peak elevation min and max
landscape.V = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs.V    = 50                  #number of individuals to simulate
nsteps.V    = 500                 #number of steps an individual can take
move.V      = c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps        = 10                 #number of replicates to run each model
parameters = expand.grid(elevation.V,landscape.V,nindvs.V,nsteps.V,move.V)
colnames(parameters) = c("elevation","landscape","nindvs","nsteps","move")
parameters = parameters[parameters$elevation!=0,]
for(r in 1:reps){
elevation = parameters$elevation[r]
landscape = parameters$landscape[r]
nindvs    = parameters$nindvs[r]
nsteps    = parameters$nsteps[r]
move = parameters$move[r]
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#plot(-100,-100, xlim=c(0,150), ylim=c(0,150))
#points(pop[,1], pop[,2], pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
for(r in 1:reps){
elevation = c(0, parameters$elevation[r])
landscape = parameters$landscape[r]
nindvs    = parameters$nindvs[r]
nsteps    = parameters$nsteps[r]
move = parameters$move[r]
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#plot(-100,-100, xlim=c(0,150), ylim=c(0,150))
#points(pop[,1], pop[,2], pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
traceback()
landscape
parameters$landscape[r]
View(pathways)
View(parameters)
parameters$landscape[r]
r
setwd("/Users/jannawilloughby/GDrive/ABMs/WILD7400_hilltopping/")
directory = getwd()
outdir    = paste(directory,"/output/", sep="")
source(paste(directory, "/source/FunctionSourcer.R", sep =''))
#parameters
elevation.V = c(0, 400)           #peak elevation min and max
landscape.V = 150                 #number of patches on each side, total patch number = landscape*landscape
nindvs.V    = 50                  #number of individuals to simulate
nsteps.V    = 500                 #number of steps an individual can take
move.V      = c(0.3,0.8)          #decimal likelihood of individual moving to highest neighbor patch (R&G call this q)
reps        = 10                 #number of replicates to run each model
parameters = expand.grid(elevation.V,landscape.V,nindvs.V,nsteps.V,move.V)
colnames(parameters) = c("elevation","landscape","nindvs","nsteps","move")
parameters = parameters[parameters$elevation!=0,]
for(p in 1:nrow(parameters)){
elevation = c(0, parameters$elevation[r])
landscape = parameters$landscape[r]
nindvs    = parameters$nindvs[r]
nsteps    = parameters$nsteps[r]
move = parameters$move[r]
for(r in 1:reps){
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#plot(-100,-100, xlim=c(0,150), ylim=c(0,150))
#points(pop[,1], pop[,2], pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
}
for(p in 1:nrow(parameters)){
elevation = c(0, parameters$elevation[p])
landscape = parameters$landscape[p]
nindvs    = parameters$nindvs[p]
nsteps    = parameters$nsteps[p]
move      = parameters$move[p]
for(r in 1:reps){
#initialize landscape
land = LandscapeInit(elevation, landscape)
image(land)
#initialize individuals on landscape
pop = NewPop(nindvs, landscape)
points(pop[,1]/150, pop[,2]/150, pch=19, cex=0.5)
#plot(-100,-100, xlim=c(0,150), ylim=c(0,150))
#points(pop[,1], pop[,2], pch=19, cex=0.5)
#allow individuals to move within landscape
pathways = NULL
for(i in 1:nrow(pop)){
#isolate individual of interest
indv = pop[i,,drop=FALSE]
#chart movement
movepath = MoveIndv(indv, land, move, nsteps, elevation, landscape)
#plot movement
lines(movepath[seq(1,length(movepath), 2)]/150, movepath[seq(2,length(movepath), 2)]/150, lwd=2)
#record path in single object for all individuals
pathways = rbind(pathways, movepath)
}
rownames(pathways) = seq(1,nindvs,1)
#extract needed output from simulation
#for this project it is fine to NOT do any stats, but you will want to export something (maybe a figure) so you and
#everyone can see how your model worked. we will use this to talk about approaches that worked well/did not work great.
}
}
traceback()
r
p
mvmt = indv[1,1:2] #x==1, y==2
mvmt
s=1
cxpos = mvmt[(length(mvmt)-1)]
cypos = mvmt[length(mvmt)]
mvmt
cxpos
cypos
#determine if indv will move randomly or will move to higher elevation
movehigh = sample(x=c(0,1), size=1, prob=c((1-move), move))
movehigh
table(sample(x=c(0,1), size=100, prob=c((1-move), move)))
table(sample(x=c(0,1), size=100, prob=c((1-move), move)), replace=F)
table(sample(x=c(0,1), size=100, prob=c((1-move), move)), replace=T)
table(sample(x=c(0,1), size=100, prob=c((1-move), move), replace=T))
table(sample(x=c(0,1), size=100, prob=c((1-move), move), replace=T))
table(sample(x=c(0,1), size=100, prob=c((1-move), move), replace=T))
move
movehigh
land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]
#initialize landscape
land = LandscapeInit(elevation, landscape)
land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]
cxpos
cypos
cypos=150
land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]
cypos=149
land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]
range(land)
#find highest elevation cell
highpt = which(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)] == max(land[(cxpos-1):(cxpos+1), (cypos-1):(cypos+1)]), arr.ind = TRUE)
highpoint
highpt
str(elevation)
elevation[,2]
dim(elevation)
dim(land)
land[1,10]
